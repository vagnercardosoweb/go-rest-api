// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0

package store

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/tabbed/pqtype"
)

type EnumInvoicesSchedulesStatus string

const (
	EnumInvoicesSchedulesStatusPaid   EnumInvoicesSchedulesStatus = "paid"
	EnumInvoicesSchedulesStatusUnpaid EnumInvoicesSchedulesStatus = "unpaid"
)

func (e *EnumInvoicesSchedulesStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EnumInvoicesSchedulesStatus(s)
	case string:
		*e = EnumInvoicesSchedulesStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for EnumInvoicesSchedulesStatus: %T", src)
	}
	return nil
}

type NullEnumInvoicesSchedulesStatus struct {
	EnumInvoicesSchedulesStatus EnumInvoicesSchedulesStatus
	Valid                       bool // Valid is true if EnumInvoicesSchedulesStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEnumInvoicesSchedulesStatus) Scan(value interface{}) error {
	if value == nil {
		ns.EnumInvoicesSchedulesStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EnumInvoicesSchedulesStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEnumInvoicesSchedulesStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return ns.EnumInvoicesSchedulesStatus, nil
}

func (e EnumInvoicesSchedulesStatus) Valid() bool {
	switch e {
	case EnumInvoicesSchedulesStatusPaid,
		EnumInvoicesSchedulesStatusUnpaid:
		return true
	}
	return false
}

func AllEnumInvoicesSchedulesStatusValues() []EnumInvoicesSchedulesStatus {
	return []EnumInvoicesSchedulesStatus{
		EnumInvoicesSchedulesStatusPaid,
		EnumInvoicesSchedulesStatusUnpaid,
	}
}

type EnumInvoicesType string

const (
	EnumInvoicesTypeIncome  EnumInvoicesType = "income"
	EnumInvoicesTypeExpense EnumInvoicesType = "expense"
)

func (e *EnumInvoicesType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EnumInvoicesType(s)
	case string:
		*e = EnumInvoicesType(s)
	default:
		return fmt.Errorf("unsupported scan type for EnumInvoicesType: %T", src)
	}
	return nil
}

type NullEnumInvoicesType struct {
	EnumInvoicesType EnumInvoicesType
	Valid            bool // Valid is true if EnumInvoicesType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEnumInvoicesType) Scan(value interface{}) error {
	if value == nil {
		ns.EnumInvoicesType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EnumInvoicesType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEnumInvoicesType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return ns.EnumInvoicesType, nil
}

func (e EnumInvoicesType) Valid() bool {
	switch e {
	case EnumInvoicesTypeIncome,
		EnumInvoicesTypeExpense:
		return true
	}
	return false
}

func AllEnumInvoicesTypeValues() []EnumInvoicesType {
	return []EnumInvoicesType{
		EnumInvoicesTypeIncome,
		EnumInvoicesTypeExpense,
	}
}

type AccessLogs struct {
	ID            uuid.UUID   `db:"id" json:"id"`
	UserID        uuid.UUID   `db:"user_id" json:"user_id"`
	IpAddress     pqtype.Inet `db:"ip_address" json:"ip_address"`
	UserAgent     string      `db:"user_agent" json:"user_agent"`
	TotalFailures int16       `db:"total_failures" json:"total_failures"`
	TotalSuccess  int16       `db:"total_success" json:"total_success"`
	CreatedAt     time.Time   `db:"created_at" json:"created_at"`
}

type Categories struct {
	ID        uuid.UUID     `db:"id" json:"id"`
	UserID    uuid.UUID     `db:"user_id" json:"user_id"`
	ParentID  uuid.NullUUID `db:"parent_id" json:"parent_id"`
	Name      string        `db:"name" json:"name"`
	SortOrder int16         `db:"sort_order" json:"sort_order"`
	CreatedAt time.Time     `db:"created_at" json:"created_at"`
	UpdatedAt time.Time     `db:"updated_at" json:"updated_at"`
	DeletedAt sql.NullTime  `db:"deleted_at" json:"deleted_at"`
}

type ForgotPasswords struct {
	ID          uuid.UUID    `db:"id" json:"id"`
	UserID      uuid.UUID    `db:"user_id" json:"user_id"`
	TokenUuid   uuid.UUID    `db:"token_uuid" json:"token_uuid"`
	ValidatedIn sql.NullTime `db:"validated_in" json:"validated_in"`
	ExpiredAt   time.Time    `db:"expired_at" json:"expired_at"`
	CreatedAt   time.Time    `db:"created_at" json:"created_at"`
}

type InvitedByUsers struct {
	ID        uuid.UUID `db:"id" json:"id"`
	UserID    uuid.UUID `db:"user_id" json:"user_id"`
	GuestID   uuid.UUID `db:"guest_id" json:"guest_id"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
}

type Invoices struct {
	ID           uuid.UUID        `db:"id" json:"id"`
	UserID       uuid.UUID        `db:"user_id" json:"user_id"`
	WalletID     uuid.UUID        `db:"wallet_id" json:"wallet_id"`
	CategoryID   uuid.UUID        `db:"category_id" json:"category_id"`
	Type         EnumInvoicesType `db:"type" json:"type"`
	ValueInCents int32            `db:"value_in_cents" json:"value_in_cents"`
	// 0 = never repeats and above 1 repeat based on the days
	RepeatableInDays  int16 `db:"repeatable_in_days" json:"repeatable_in_days"`
	TotalInstallments int16 `db:"total_installments" json:"total_installments"`
	// Day of the month that will be paid, used to generate the due_date of the schedules
	Payday    int16        `db:"payday" json:"payday"`
	StartAt   time.Time    `db:"start_at" json:"start_at"`
	EndAt     sql.NullTime `db:"end_at" json:"end_at"`
	CreatedAt time.Time    `db:"created_at" json:"created_at"`
	UpdatedAt time.Time    `db:"updated_at" json:"updated_at"`
	DeletedAt sql.NullTime `db:"deleted_at" json:"deleted_at"`
}

type InvoicesSchedules struct {
	ID                uuid.UUID                   `db:"id" json:"id"`
	InvoiceID         uuid.UUID                   `db:"invoice_id" json:"invoice_id"`
	InstallmentNumber int16                       `db:"installment_number" json:"installment_number"`
	Status            EnumInvoicesSchedulesStatus `db:"status" json:"status"`
	PaidAt            sql.NullTime                `db:"paid_at" json:"paid_at"`
	UnpaidAt          sql.NullTime                `db:"unpaid_at" json:"unpaid_at"`
	DueDate           time.Time                   `db:"due_date" json:"due_date"`
	UpdatedAt         time.Time                   `db:"updated_at" json:"updated_at"`
	CreatedAt         time.Time                   `db:"created_at" json:"created_at"`
	DeletedAt         sql.NullTime                `db:"deleted_at" json:"deleted_at"`
}

type Users struct {
	ID                  uuid.UUID    `db:"id" json:"id"`
	Name                string       `db:"name" json:"name"`
	Email               string       `db:"email" json:"email"`
	BirthDate           time.Time    `db:"birth_date" json:"birth_date"`
	CodeToInvite        string       `db:"code_to_invite" json:"code_to_invite"`
	PasswordHash        string       `db:"password_hash" json:"password_hash"`
	TokenToConfirmEmail uuid.UUID    `db:"token_to_confirm_email" json:"token_to_confirm_email"`
	ConfirmedEmailAt    sql.NullTime `db:"confirmed_email_at" json:"confirmed_email_at"`
	LoginBlockedUntil   sql.NullTime `db:"login_blocked_until" json:"login_blocked_until"`
	CreatedAt           time.Time    `db:"created_at" json:"created_at"`
	UpdatedAt           time.Time    `db:"updated_at" json:"updated_at"`
	DeletedAt           sql.NullTime `db:"deleted_at" json:"deleted_at"`
}

type Wallets struct {
	ID        uuid.UUID    `db:"id" json:"id"`
	UserID    uuid.UUID    `db:"user_id" json:"user_id"`
	Name      string       `db:"name" json:"name"`
	SortOrder int16        `db:"sort_order" json:"sort_order"`
	CreatedAt time.Time    `db:"created_at" json:"created_at"`
	UpdatedAt time.Time    `db:"updated_at" json:"updated_at"`
	DeletedAt sql.NullTime `db:"deleted_at" json:"deleted_at"`
}
